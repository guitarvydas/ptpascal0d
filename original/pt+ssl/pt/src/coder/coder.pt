{  PT Code Generator for the SUN Ver. 1.04
   after the PT Code Generator for the VAX Ver. 1.02
   after the PT Code Generator for the PDP-11 Ver. 1.04.

   Date: 30 Jun 1980
	  (Converted to VAX 27 Aug 1985)
	  (Converted to SUN 1 Sept 1987)
	  (Revised 10 Jan 1990)

   Author: Alan Rosselet, University of Toronto
	    VAX conversion by J.R. Cordy, Queen's University at Kingston
	    SUN conversion by J.R. Cordy, Queen's University at Kingston

   Abstract:
     The code generator translates PT intermediate code, tcode, into
   SUN/3 assembly code.  The only interface to the preceding pass is
   the tcode stream.  Data allocation has already been done by the
   semantic analysis pass with variable addresses passed in the tcode.
   The coder attempts to produce locally good code by maintaining a
   stack of data descriptors which mimic the contents of the runtime
   stack during expression processing.  The coder translates Boolean
   expressions into control flow.


   Input Files

	SslFile: S/SL table generator from coder.ssl

	options: Compiler options

	tCode: TCode instructions generated by the semantic analysis
	        pass for the source program.


   Output Files

	object: Object Sun/3 assembly code

	output: diagnostic messages.

}


program Coder (output, coderSsl, tCode, object, options);

    const
	{ T-Code tokens. N.B. These token values must match the
	  T-Code token values emitted by the semantic pass.     }
	firstInputToken = 0;
	{  tMultiply = 0;
	tDivide = 1;
	tModulus = 2;
	tAdd = 3;
	tSubtract = 4;
	tEQ = 5;
	tNE = 6;
	tGT = 7;
	tGE = 8;
	tLT = 9;
	tLE = 10;
	tAnd = 11;
	tInfixAnd = 12;
	tOr = 13;
	tInfixOr = 14;
	tNegate = 15;
	tNot = 16;
	tChr = 17;
	tOrd = 18;
	tEoln = 19;
	tEOF = 20;
	tVarParm = 21;
	tFetchAddress = 22;
	tFetchInteger = 23;
	tFetchChar = 24;
	tFetchBoolean = 25;
	tAssignBegin = 26;
	tAssignAddress = 27;
	tAssignInteger = 28;
	tAssignChar = 29;
	tAssignBoolean = 30;
	tStoreParmAddress = 31;
	tStoreParmInteger = 32;
	tStoreParmChar = 33;
	tStoreParmBoolean = 34;
	tSubscriptBegin = 35;
	tSubscriptAddress = 36;
	tSubscriptInteger = 37;
	tSubscriptChar = 38;
	tSubscriptBoolean = 39;
	tArrayDescriptor = 40;  }
	tFileDescriptor = 41;
	{  tIfBegin = 42;
	tIfEnd = 43;
	tCaseBegin = 44;
	tWhileBegin = 45;
	tRepeatBegin = 46;
	tRepeatControl = 47;
	tCallBegin = 48;  }
	tParmEnd = 49;
	{  tProcedureEnd = 50;
	tWriteBegin = 51;
	tReadBegin = 52;
	tPopStack = 53;  }

	firstCompoundToken = 54;
	tLiteralAddress = 54;
	tLiteralInteger = 55;
	tLiteralChar = 56;
	tLiteralBoolean = 57;
	tLiteralString = 58;
	tStringDescriptor = 59;
	tSkipString = 60;
	tIfThen = 61;
	tIfMerge = 62;
	tCaseSelect = 63;
	tCaseMerge = 64;
	tCaseEnd = 65;
	tWhileTest = 66;
	tWhileEnd = 67;
	tRepeatTest = 68;
	tSkipProc = 69;
	tCallEnd = 70; 
	tLineNumber = 71;
	tTrap = 72;
	lastCompoundToken = 72;

	{ Dummy tcode used only as an end of file marker }
	tEndOfFile = 73;
	lastInputToken = 73;

	{ S/SL table operations }
	firstTableOperation = 0;
	{ Primitive operations }
	oCall = 0;
	oReturn = 1;
	oRuleEnd = 2;
	oJumpBack = 3;
	oJumpForward = 4;
	oInput = 5;
	oInputAny = 6;
	oInputChoice = 7;
	oEmit = 8;
	oError = 9;
	oChoice = 10;
	oChoiceEnd = 11;
	oSetParameter = 12;
	oSetResult = 13;

	{ Semantic Operations }
	oTempAllocate = 14;
	oTempFree = 15;
	oOperandPushMode = 16;
	oOperandChooseMode = 17;
	oOperandPushVariable = 18;
	oOperandPushInteger = 19;
	oOperandPushChar = 20;
	oOperandPushBoolean = 21;
	oOperandPushJumpCondition = 22;
	oOperandChooseJumpCondition = 23;
	oOperandPushStringDescriptor = 24;
	oOperandPushProcedure = 25;
	oOperandPushTrap = 26;
	oOperandPushCaseLow = 27;
	oOperandPushCaseHigh = 28;
	oOperandPushArrayLowerBound = 29;
	oOperandPushCopy = 30;
	oOperandPushTemp = 31;
	oOperandSetMode = 32;
	oOperandSetLength = 33;
	oOperandChooseLength = 34;
	oOperandSetValue = 35;
	oOperandChooseValue = 36;
	oOperandChooseManifestValue = 37;
	oOperandIsValueNegative = 38;
	oOperandEnterValueFromCaseTableAddress = 39;
	oOperandEnterValueFromCodeAddress = 40;
	oOperandEnterValueFromStringLength = 41;
	oOperandEnterValueFromDataAreaSize = 42;
	oOperandCompareLeftAndRight = 43;
	oOperandCompareRightAndDestination = 44;
	oOperandIsJumpCondition = 45;
	oOperandComplementJumpCondition = 46;
	oOperandAddManifestValues = 47;
	oOperandSubtractManifestValues = 48;
	oOperandNegateManifestValue = 49;
	oOperandCompareManifestValues = 50;
	oOperandMergeShuntsWithAddress = 51;
	oOperandMergeShunts = 52;
	oOperandFoldManifestSubscript = 53;
	oOperandSwap = 54;
	oOperandSwapRightAndDestination = 55;
	oOperandPop = 56;
	oFixPushAddress = 57;
	oFixPushLastAddress = 58;
	oFixSwapAddresses = 59;
	oFixAndFreeShuntList = 60;
	oFixAndFreeFalseBranches = 61;
	oFixForwardBranch = 62;
	oFixPopAddress = 63;
	oEmitProcLabel = 64;
	oEmitNone = 65;
	oEmitSingle = 66;
	oEmitDouble = 67;
	oEmitString = 68;
	oEmitStringLength = 69;
	oEmitConditionalForwardBranch = 70;
	oEmitUnconditionalForwardBranch = 71;
	oEmitConditionalBackwardBranch = 72;
	oEmitUnconditionalBackwardBranch = 73;
	oEmitSourceCoordinate = 74;
	oEmitMergeSourceCoordinate = 75;
	oEmitCaseMergeBranch = 76;
	oEmitCaseBranchTable = 77;
	oCasePush = 78;
	oCasePop = 79;
	oCaseEnterTCodeAddress = 80;
	oCaseEnterVariantAddress = 81;
	oCaseEnterMergeAddress = 82;
	oCaseEnterAbortAddress = 83;
	oArrayEnterLowerBound = 84;
	oArrayEnterUpperBound = 85;
	oOptionTestChecking = 86;
	lastTableOperation = 86;

	{ Error Codes }
	firstErrorCode = 10;
	eDivisionByZero = 10;

	firstFatalError = 21;
	eFixStackOvfl = 21;
	eOperandStkOvfl = 22;
	eSslStackOvfl = 24;
	eProcAddrTableOvfl = 25;
	eCaseLimitExceeded = 26;
	eArrayBoundsOvfl = 28;
	eCaseStackOvfl = 29;
	eShuntListExhausted = 30;
	lastErrorCode = 30;

	{ Type Values }
	null = 0;
	byte = 1;
	word = 2;
	no = 0;
	yes = 1;

	firstOpCode = -9;
	iJalways = -9;
	iJhi = -8;
	iJlos = -7;
	iJge = -6;
	iJlt = -5;
	iJle = -4;
	iJgt = -3;
	iJne = -2;
	iJeq = -1;
	iJnever = 0;
	lastJumpCode = 0;

	iAdd = 1;
	iClr = 2;
	iCmp = 3;
	iDec = 4;
	iDiv = 5;
	iInc = 6;
	iMov = 7;
	iMul = 8;
	iNeg = 9;
	iSub = 10;
	iTst = 11;
	iJmp = 12;
	iBsr = 13;
	iRts = 14;
	iGlobl = 15;
	iJsr = 16;
	iText = 17;
	iData = 18;
	iWord = 19;
	iSpace = 20;
	iLoada = 21;
	iPusha = 22;
	iAsl = 23;
	lastOpCode = 23;

	{ S/SL System Failure Codes }
	firstFailureCode = 0;
	fSemanticChoiceFailed = 0;
	fChoiceRuleFailed = 1;
	lastFailureCode = 1;


	{ Coder Limits }

	sslTableSize =	4000;	{ Max }
	maxInteger = 32767;
	minInteger = -32767;
	sslStackSize = 100;
	operandStkSize = 80;
	fixStackSize = 250;
	caseTableSize =  256;	{ max number of alternatives in a case stmt }
	caseStackSize =  20;	{ max nesting of case statements }
	maxShunts = 64;
	maxLiteralLength = 80;	{ should match max in previous pass }
	maxArrayBounds = 200;
	memorySize = 32000;
	maxLineNumber = 9999;

	{ Addressing Mode }	   	{ SUN Notation }

	mStatic = 1;			{ u+NNN }
	mStaticManifest = 2;		{ #u+NNN }
	mTemp = 3;			{ dN }
	mAddressTemp = 4;		{ aN }
	mAddressTempIndirect = 5;	{ aN@ }
	mAddressTempAutoIncrement  = 6;	{ aN@+ }
	mAddressTempIndirectCaseOffset = 7;  { aN@(cNNN:l) }
	mStack = 8;			{ sp@ }
	mPushStack = 9;			{ sp@- }
	mPopStack = 10;			{ sp@+ }
	mManifest = 11;			{ #NNN }
	mLineReg  = 12;			{ d7 }
	mProc = 13;			{ proc label }
	mTrap  = 14;			{ external trap proc label }
	mString = 15;			{ string label  }
	mWord = 16;			{ NNN }

	{ Machine word size }
	wordSize = 4;		{ longword (4 bytes) on SUN }

	{ Temporary reg pairs }
	firstTempReg = 1;	{ d1, a1 }
	lastTempReg = 4;	{ d4, a4 }

	{ Misc }
	undefined = minInteger;

	{ Assertion identification values }
	assert1 = 1;
	assert2 = 2;
	assert3 = 3;
	assert4 = 4;
	assert5 = 5;
	assert6 = 6;
	assert7 = 7;
	assert8 = 8;
	assert9 = 9;
	assert10 = 10;
	assert11 = 11;
	assert12 = 12;
	assert13 = 13;
	assert14 = 14;
	assert15 = 15;
	assert16 = 16;
	assert17 = 17;
	assert18 = 18;
	assert19 = 19;
	assert20 = 20;
	assert21 = 21;
	assert22 = 22;
	assert23 = 23;
	assert24 = 24;
	assert25 = 25;
	assert26 = 26;
	assert27 = 27;
	assert28 = 28;
	assert29 = 29;
	assert30 = 30;
	assert31 = 31;
	assert32 = 32;
	assert33 = 33;
	assert34 = 34;
	assert35 = 35;
	assert36 = 36;
	assert37 = 37;
	assert38 = 38;
	assert39 = 39;
	assert40 = 40;
	assert41 = 41;
	assert42 = 42;
	assert43 = 43;
	assert44 = 44;
	assert45 = 45;
	assert46 = 46;
	assert47 = 47;
	assert48 = 48;
	assert49 = 49;
	assert50 = 50;
	assert51 = 51;
	assert52 = 52;
	assert53 = 53;
	assert54 = 54;

    type
	ShuntRef = undefined .. maxShunts;
	OperandStkRef = 0 .. operandStkSize;
	InputTokens = firstInputToken .. lastInputToken;
	ErrorCodes = firstErrorCode .. lastErrorCode;
	FailureCodes = firstFailureCode .. lastFailureCode;

    var 
	{ The Syntax/Semantic Table;
	  The S/SL table file produced by the S/SL Processor 
	  for the pass is read into this array during initialization. }
	sslTable:
	    array [0 .. sslTableSize] of integer;
	coderSsl:
	    file of integer;

	{ Table Walker State }
	processing:
	    Boolean  { initially true };
	sslPointer:
	    0 .. sslTableSize  { initially 0 };
	operation:
	    firstTableOperation .. lastTableOperation;

	{ Tracing Control }
	options:
	    file of char;
	tracing:
	    Boolean  { initially false };
	lineNumbering:
	    Boolean  { initially true };
	checking:
	    Boolean  { initially true };

	{ Abort flag }
	abort:
	    Boolean  { initially false };

	{ The S/SL Rule Call Stack:
	  The Rule Call Stack implements Syntax/Semantic
	  Language rule call and return.
	  Each time an oCall operation is executed,
	  the table return address is pushed onto the
	  Rule Call Stack.  When an oReturn is executed,
	  the return address is popped from the stack.
	  An oReturn executed when the Rule Call Stack is
	  empty terminates table execution.		}
	sslStack:
	    array [1 .. sslStackSize] of 0 .. sslTableSize;
	sslStackTop:
	    0 .. sslStackSize  { initially 0 };

	{ Choice Match Flag:
	  Set by the Choice Handler to indicate whether
	  a match was made or the otherwise path was taken.
	  Set to true if a match was made and false otherwise.
	  This flag is used in input choices to indicate
	  whether the choice input token should be accepted or
	  not.							}
	choiceTagMatched:
	    Boolean;

	{ Parameterized And Choice Semantic Operation Values:
	  These are used to hold the decoded parameter value to
	  a parameterized semantic operation and the result
	  value returned by a choice semantic operation
	  or rule respectively.					 }
	parameterValue:
	    integer;
	resultValue:
	    integer;

	{ Line Counters }
	nextLineNumber:
	    0 .. maxLineNumber	{ initially 0 };
	lineNumber:
	    0 .. maxLineNumber;
	lastEmittedLineNumber:	integer;

	{ Error Counter }
	noErrors:
	    integer  { initially 0 };

	{ Input Interface }
	tCode:
	    file of integer;
	nextInputToken:
	    InputTokens;

	{ The Compound Input Token Buffer;
	  When a compound input token is accepted from
	  the input stream, its associated value is
	  saved in the compound token buffer for use by
	  the Semantic Mechanisms of the pass.		}
	compoundToken:
	    InputTokens;	{ Last compound input token accepted }
	compoundTokenValue:
	    integer;		{ Its associated value; often more than
				 simply an integer }
	compoundTokenLength: integer;
	compoundTokenText: array [1 .. maxLiteralLength] of integer;

	{ tCaseEnd is a special compound token whose "value" consists
	  of a lowest case label value, a highest case label value and
	  a case branch table.					     }
	caseLow: integer;
	caseHigh: integer;
	tCodeCaseTable: array [1 .. caseTableSize] of integer;


	buffer: integer;

	{ Output Interface }
	object: file of char;	{ Object assembly code file }


	{ Global Temporary }
	i: integer;


	{ Temporary Mechanism }
	tempregfree: array [firstTempReg .. lastTempReg] of boolean;
	tempregnum: integer;


	{ Operand Stack }

	{ The kind field can contain either an addressing mode or
	  a jump condition (e.g. bne).				}
	operandStkKind: array [1 .. operandStkSize] of integer;

	{ The value field can contain either an data value (e.g. manifest
	  value or variable address) or a pointer to the head of a 
	  shunt (true branch) list from a Boolean expression.		}
	operandStkValue: array [1 .. operandStkSize] of integer;

	{ The regnum field contains the register number of a temporary
	  register if any						}
	operandStkRegnum: array [1 .. operandStkSize] of integer;

	{ The length field can contain either a symbol length (e.g. byte
	  or word) or a pointer to the head of a false branch list from
	  a Boolean expression.						}
	operandStkLength: array [1 .. operandStkSize] of integer;

	operandStkTop: 0 .. operandStkSize;


	{ The Array Table contains bounds for manifest subscript checking }
	arrayDscrAddr: array [1 .. maxArrayBounds] of integer;
	arrayLowers: array [1 .. maxArrayBounds] of integer;
	arrayUppers: array [1 .. maxArrayBounds] of integer;
	arrayBoundsTop: 0 .. maxArrayBounds;


	{ Fix Address stack }
	fixStack: array [1 .. fixStackSize] of integer;
	fixStackTop: 0 .. fixStackSize;	{ initially 0 }

	{ Fix label number - used in generating unique branch labels }
	fixLabelNumber: integer;	{ initially 0 }

	{ Shunt list elements, used in converting Boolean expressions
	  to control flow.  An element consists of 2 fields: a link to
	  the next element in the list and a code area address.  The
	  address field points to a forward branch instruction which must
	  have its target filled in.					}
	shuntFreeListHead: ShuntRef;
	shuntAddress: array [1 .. maxShunts] of integer;
	shuntLink: array [1 .. maxShunts] of ShuntRef;

	{ Case Stack - contains label-address pairs for all (nested)
		case statements currently being processed. }
	caseStackTop:	0 .. caseStackSize;
	caseTCodeAddr:	array [1 .. caseStackSize] of integer;

	{ Address (offset) of the last tcode
	  instruction to be read from the tcode file }
	tCodeAddress: integer;	{ initially 1 }
	nextTCodeAddress: integer;	{ initially 1 }

	{ The size of the data area is read from the tcode file
	  and written to the object file.			}
	dataAreaSize: integer;


	{ UNIX argument file names }
	{ NcoderSsl, NtCode, Nobject, Noptions:
		packed array [1 .. 50] of char; }






    procedure Assert (assertion: Boolean; assertNumber: integer);
	{ Procedure to implement programmer assertion checking
	  with identification numbers.				}
	begin
	    if not assertion then
		begin
		    write ('### Coder Assertion ', assertNumber: 1, ' failed');
		    writeln;
		    { Cause a crash }
		    case 2 of 1: end;
		end;
	end { Assert };



    procedure SubscriptError (subscript: integer;
			     lowerBound: integer;
			     upperBound: integer);
	{ Report a manifest subscript out of bounds. }
	begin
	    write ('line ', lineNumber: 1, ': subscript [',
		  subscript: 1, '] out of bounds [',
		  lowerBound: 1, ' .. ', upperBound: 1, ']');
	    writeln;
	    noErrors := noErrors + 1;
	end { SubscriptError };

    procedure Error (errorCode: ErrorCodes);
	{ Report an error and abort processing if the error was fatal. }
	begin
	    write ('line ', lineNumber:1, ': ');
	    if errorCode > firstFatalError then
		write ('program too complicated ');
	    case errorCode of
		eDivisionByZero: write ('division by zero');
		eOperandStkOvfl: write (' (operand stack)');
		eFixStackOvfl: write (' (fix address stack)');
		eSslStackOvfl: write (' (SSL stack)');
		eProcAddrTableOvfl: write (' (procedure table)');
		eCaseLimitExceeded: write (' (case stack)');
		eArrayBoundsOvfl: write (' (array table)');
		eCaseStackOvfl: write (' (case stack)');
		eShuntListExhausted: write (' (shunt free list)');
	    end;
	    writeln;
	    noErrors := noErrors + 1;
	    if errorCode >= firstFatalError then
		begin
		    processing := false;	{ terminate coding }
		    abort := true;
		end;
	end { Error };

    procedure Initialize;				
	{ Set the compiler options from the options file, read in the
	  S/SL table corresponding to coder.ssl, initialize the coder
	  semantic mechanisms.					    }

	var
	    i: integer;
	    c: char;

	begin
	    { Get UNIX argument file names }
	    {
	    argv (1, NcoderSsl);
	    argv (2, NtCode);
	    argv (3, Nobject);
	    argv (4, Noptions);
	    }

	    { Trace Execution if Required }
	    tracing := false;
	    lineNumbering := true;
	    checking := true;
	    reset (options {, Noptions} );

	    while not eof (options) do
		begin
		    read (options, c);
		    if c = 't' then
			read (options, c);
			if (c = '4') then
			    tracing := true
		    else if c = 'l' then
			lineNumbering := false
		    else if c = 'k' then
			checking := false
		    else if c = 'O' then
			begin
			    checking := false;
			    lineNumbering := false;
			end;
		end;

	    { Initialize the coder ssl table }
	    reset (coderSsl {, NcoderSsl} );
	    i := 0;
	    while not eof (coderSsl) do
		begin
		    if i > sslTableSize then
			Assert (false, assert23);
		    read (coderSsl, sslTable[i]);
		    i := i + 1
		end;


	    { Initialize Input/Output }
	    rewrite (object {, Nobject} );
	    reset (tCode {, NtCode} );
	    { Provide a dummy (non-compound) lookahead
	      token for the first call to AcceptInputToken }
	    nextInputToken := tParmEnd;
	    nextLineNumber := 1;

	    { Initialize semantic mechanisms }
	    { Set up the Shunt free list. 
	      Assumes that shunt list is non-null. }
	    shuntFreeListHead := 1;
	    i := 1;
	    while i < maxShunts do
		begin
		    shuntLink[i] := i + 1;
		    i := i + 1
		end;
	    shuntLink[i] := undefined;
	    i := firstTempReg;
	    while i <= lastTempReg do
		begin
		    tempregfree[i] := true;
		    i := i + 1;
		end;
	    operandStkTop := 0;
	    fixStackTop := 0;
	    fixLabelNumber := 0;
	    caseStackTop := 0;
	    tCodeAddress := 1;
	    nextTCodeAddress := 1;

	    { Discard the error count word, the ptc command file has already
	      checked it and aborted compilation if semantic errors were found.}
	    read (tCode, buffer);

	    read (tCode, dataAreaSize);
	    { Round the data area size up to a word (VAX 4 byte) boundary }
	    dataAreaSize := dataAreaSize + dataAreaSize mod wordSize;

	    read (tCode, buffer);	{ tCode size }
	end { Initialize };







{ Procedures to implement the Coder semantic mechanisms. }


    procedure ReverseSense (var branchop: integer);	
	{ Invert the parameter jump condition (e.g. bge => blt). }
	{ The opcode is assumed to in the SSL encoding. }
	begin
	    Assert ( (branchop >= iJalways) and (branchop <= iJnever), assert2);
	    if branchop div 2 * 2 = branchop then
		branchop := branchop + 1
	    else
		branchop := branchop - 1;
	    { handle special case of unconditional jumps }
	    if branchop = -10 then
		branchop := 0
	      else if branchop = 1 then
		branchop := -9
	end { ReverseSense };

    procedure AllocateShunt (var newShunt: ShuntRef);
	{ Allocate a shunt descriptor from the shunt descriptor free list }

	begin
	    if shuntFreeListHead <> undefined then
		begin
		    newShunt := shuntFreeListHead;
		    shuntFreeListHead := shuntLink[shuntFreeListHead]
		end
	    else
		Error (eShuntListExhausted);
	end { AllocateShunt };

    procedure FreeShuntList (next: ShuntRef);
	{ Return the list of shunt descriptors headed by the parameter
	  descriptor to the shunt descriptor free list.		     }
	var
	    current:		ShuntRef;

	begin
	    while next <> undefined do
		begin
		    current := next;
		    next := shuntLink[current];
		    shuntLink[current] := shuntFreeListHead;
		    shuntFreeListHead := current
		end
	end { FreeShuntList };




    { Emit Mechanism procedures }


    procedure EmitSunLabel (labelChar: char; labelNumber: integer);
	{ Emit a Sun/3 assembly code label }
	begin
	    write (object, labelChar, labelNumber: 1, ':');
	end { EmitSunLabel };


    procedure EmitSunStringLiteral;
	{ Emit a Sun/3 assembly code string constant }
	var
	    i:	1 .. maxLiteralLength;
	begin
	    Assert ( (compoundToken = tLiteralString), assert26);
	    write (object, '	.asciz	"');

	    i := 1;
	    repeat
		if (compoundTokenText[i] = ord('"')) or
			(compoundTokenText[i] = ord('\')) then
		    write (object, '\');
		write (object, chr (compoundTokenText[i]));
		i := i + 1
	    until i > compoundTokenLength;

	    write (object, '"');
	    writeln (object);
	end { EmitSunStringLiteral };


    procedure EmitSunCode (opcode: integer; byte: Boolean);
	{ Emit the Sun/3 assembly notation for 'opcode' to the object file }
	begin
	    write (object, '	');

	    case opcode of
		iJalways:
		    write (object, 'jra');
		iJhi:
		    write (object, 'jhi');
		iJlos:
		    write (object, 'jls');
		iJge:
		    write (object, 'jge');
		iJlt:
		    write (object, 'jlt');
		iJle:
		    write (object, 'jle');
		iJgt:
		    write (object, 'jgt');
		iJne:
		    write (object, 'jne');
		iJeq:
		    write (object, 'jeq');
		iJnever:
		    Assert (false, assert46);
		iGlobl:
		    write (object, '.globl');
		iBsr:
		    write (object, 'jbsr');
		iRts:
		    write (object, 'rts');
		iJsr:
		    write (object, 'jbsr');
		iJmp:
		    write (object, 'jra');
		iText:
		    write (object, '.text');
		iData:
		    write (object, '.data; .align 2');
		iWord:
		    write (object, '.long');
		iSpace:
		    write (object, '.lcomm u,');
		iAdd:
		    write (object, 'addl');
		iInc:
		    write (object, 'addql #1,');
		iSub:
		    write (object, 'subl');
		iMul:
		    write (object, 'mulsl');
		iDiv:
		    write (object, 'divsl');
		iLoada:
		    write (object, 'lea');
		iPusha:
		    write (object, 'pea');
		iAsl:
		    write (object, 'asll');

		{ Multi-sized Opcodes }

		iCmp, iMov, iTst, iClr, iNeg :
		    begin
			case opcode of
			    iCmp:
				write (object, 'cmp');
			    iMov:
				write (object, 'mov');
			    iTst:
				write (object, 'tst');
			    iClr:
				write (object, 'clr');
			    iNeg:
				write (object, 'neg');
			end { case };

			if byte then
			    write (object, 'b')
			else
			    write (object, 'l');
		    end;

		iDec:
		    begin
			write (object, 'subq');

			if byte then
			    write (object, 'b')
			else
			    write (object, 'l');

			write (object, ' #1,');
		    end;
	    end { case };

	    write (object, '	');
	end;  { EmitSunCode }


    procedure EmitSunMode (mode: integer; offset: integer; regnum: integer;
		length: integer);
	{ Emit the Sun/3 assembly notation for 'mode' with 'offset'
	  to the object file }
	var i: integer;
	    iend: integer;
	begin
	    case mode of
		mStatic:	
		    write (object, 'u+', offset: 1);
		mStaticManifest:	
		    write (object, '#u+', offset: 1);
		mTemp:	
		    write (object, 'd', regnum: 1);
		mAddressTemp:	
		    write (object, 'a', regnum: 1);
		mAddressTempIndirect:	
		    write (object, 'a', regnum: 1, '@');
		mAddressTempAutoIncrement:	
		    write (object, 'a', regnum: 1, '@+');
		mAddressTempIndirectCaseOffset:	
		    write (object, 'a', regnum: 1, '@(c', offset: 1, ':l)');
		mStack:
		    write (object, 'sp@');
		mPushStack:
		    write (object, 'sp@-');
		mPopStack:
		    write (object, 'sp@+');
		mManifest:	
		    write (object, '#', offset: 1);
		mLineReg:	
		    write (object, 'd7');
		mProc:
		    write (object, 'p', offset: 1);
		mTrap:	
		    write (object, 't', offset: 1);
		mString:
		    write (object, '#s', offset: 1);
		mWord:
		    write (object, offset: 1);
	    end { case };
	end;  { EmitSunMode }


    procedure EmitSunSrcMode (mode: integer; offset: integer; 
		regnum: integer; length: integer);
	begin
	    EmitSunMode (mode, offset, regnum, length);
	    write (object, ',');
	end { EmitSunSrcMode };


    procedure EmitSunDstMode (mode: integer; offset: integer; 
		regnum: integer; length: integer);
	begin
	    EmitSunMode (mode, offset, regnum, length);
	    writeln (object);
	end { EmitSunDstMode };


    procedure EmitSunDstLabel (labelChar: char; labelNumber: integer);
	{ Emit a Sun/3 assembly code label as destination operand }
	begin
	    write (object, labelChar, labelNumber: 1);
	    writeln (object);
	end { EmitSunDstLabel };


    procedure EmitSunNone;
	begin
	    writeln (object);
	end { EmitSunNone };


    procedure EmitDouble (opCode: integer);
	{ Emit a double operand instruction with the parameter opcode,
	  the source operand addressing mode of the top operand stack
	  entry and the destination operand addressing mode of the top-1
	  operand stack entry.  If an addressing mode requires an
	  associated manifest value (e.g. addressing mode is Index)
	  take that value from the value field of the addressing mode's
	  operand stack entry.						}
	var
	    sourceMode:		integer;
	    sourceOffset:	integer;
	    sourceRegnum:	integer;
	    sourceLength:	integer;
	    destMode:		integer;
	    destOffset:		integer;
	    destRegnum:		integer;
	    destLength:		integer;
	    byteFlag:		Boolean;	

	begin
	    Assert ( (operandStkTop >= 2), assert38);
	    byteFlag := false;

	    if operandStkLength[operandStkTop] = byte then
		byteFlag := true;

	    EmitSunCode (opCode, byteFlag);

	    sourceMode := operandStkKind[operandStkTop];
	    sourceOffset := operandStkValue[operandStkTop];
	    sourceRegnum := operandStkRegnum[operandStkTop];
	    sourceLength := operandStkLength[operandStkTop];

	    EmitSunSrcMode (sourceMode, sourceOffset, sourceRegnum,
		sourceLength);

	    destMode := operandStkKind[operandStkTop-1];
	    destOffset := operandStkValue[operandStkTop-1];
	    destRegnum := operandStkRegnum[operandStkTop-1];
	    destLength := operandStkLength[operandStkTop-1];

	    EmitSunDstMode (destMode, destOffset, destRegnum, destLength);
	end { EmitDouble };

    procedure EmitSingle (opCode: integer);
	{ Emit a single operand instruction with the parameter opcode
	  and the addressing mode of the top operand stack entry.  If
	  the adressing mode requires an associated manifest value
	  (e.g. addressing mode is Index) that value is taken from the
	  top operand stack entry's value field.			}
	var
	    mode:	integer;
	    offset:	integer;
	    regnum:	integer;
	    length:	integer;
	    byteFlag:	Boolean;	

	begin
	    byteFlag := false;

	    if operandStkLength[operandStkTop] = byte then
		byteFlag := true;

	    EmitSunCode (opCode, byteFlag);

	    mode := operandStkKind[operandStkTop];
	    offset := operandStkValue[operandStkTop];
	    regnum := operandStkRegnum[operandStkTop];
	    length := operandStkLength[operandStkTop];

	    EmitSunDstMode (mode, offset, regnum, length);
	end { EmitSingle };

    procedure EmitNone (opCode: integer);
	{ Emit a zero-operand instruction }
	begin
	    EmitSunCode (opCode, false);
	    EmitSunNone;
	end { EmitNone };

    procedure EmitProcLabel (mode: integer);
	{ Emit the label for a procedure }
	begin
	    EmitSunLabel ('p', tCodeAddress)
	end { EmitProcLabel };

    procedure EmitString;
	{ Emit the text associated with the last tLiteralString
	  token accepted (packed one character per byte).	}
	begin
	    Assert ( (compoundToken = tLiteralString), assert26);
	    { The string's T-code address is used as its label }
	    EmitSunLabel ('s', tCodeAddress);
	    EmitSunStringLiteral;
	end { EmitString };

    procedure EmitForwardBranch (branchOperation: integer;
			 labelNumber: integer);
	{ Emit a forward branch instruction with the 
	  parameter branch operation and label.	}
	begin
	    EmitSunCode (branchOperation, false);
	    EmitSunDstLabel ('f', labelNumber);
	end { EmitForwardBranch };


    procedure EmitUnconditionalForwardBranch;
	begin
	    EmitForwardBranch (iJalways, fixLabelNumber + 1);
	end { EmitUnconditionalForwardBranch };


    procedure EmitConditionalForwardBranch;
	var
	    branchOperation: integer;
	begin
	    branchOperation := operandStkKind[operandStkTop];
	    Assert ( (branchOperation <> iJnever), assert33);
	    EmitForwardBranch (branchOperation, fixLabelNumber + 1);
	end { EmitConditionalForwardBranch };


    procedure EmitBackwardBranch (branchOperation: integer;
			 labelNumber: integer);
	{ Emit a backward branch instruction with the 
	  parameter branch operation and label.	}
	begin
	    EmitSunCode (branchOperation, false);
	    EmitSunDstLabel ('b', labelNumber);
	end { EmitBackwardBranch };

    procedure EmitUnconditionalBackwardBranch;
	{ Emit an unconditional backward branch instruction whose target
	  label is the top fix address stack entry. }
	begin
	    EmitBackwardBranch (iJalways, fixStack[fixStackTop]);
	end { EmitUnconditionalBackwardBranch };

    procedure EmitConditionalBackwardBranch;
	{ Emit a conditional backward branch instruction with the
	  branch condition of the top operand and with the top address
	  fix stack entry as its target label.  }
	var
	    branchOperation:	integer;
	begin
	    branchOperation := operandStkKind[operandStkTop];
	    Assert ( (branchOperation <> iJnever), assert35);
	    EmitBackwardBranch (branchOperation, fixStack[fixStackTop]);
	end { EmitConditionalBackwardBranch };

    procedure EmitCaseBranchTable;
	{ Emit a table of case alternative addresses.  
	  The table is constructed from the case branch table in
	  the tcode stream using the tcode address of each alternative 
	  as a label tag for the alternative's code. }
	var
	    i: integer;
	    tCodeLoc: integer;
	begin
	    i := 1;	{ tCode case table index }
	    EmitNone (iData);
	    EmitSunLabel ('c', caseTCodeAddr[caseStackTop]);
	    repeat
		tCodeLoc := tCodeCaseTable[i];
		EmitSunCode (iWord, false);

		if tCodeLoc > 0 then
		    { Alternative exists }
		    EmitSunDstLabel ('v', tCodeLoc)
		else
		    { No alternative for this value - use case abort label }
		    EmitSunDstLabel ('a', caseTCodeAddr[caseStackTop]);
		i := i + 1
	    until i > caseHigh - caseLow + 1;
	    EmitNone (iText);
	end { EmitCaseBranchTable };



{  Fix Address Mechanism procedures }

    procedure FixPushAddress;
	begin
	    if fixStackTop < fixStackSize then
		begin
		    fixStackTop := fixStackTop + 1;
		    fixLabelNumber := fixLabelNumber + 1;
		    { Save the label used for the backward branch }
		    fixStack[fixStackTop] := fixLabelNumber;
		    EmitSunLabel ('b', fixLabelNumber);
		end
	    else
		Error (eFixStackOvfl);
	end { FixPushAddress };

    procedure FixPushLastAddress;
	{ Save the tCode address of a forward branch instruction
	  operand which will be used as the label when the target location
	  becomes known.				 }
	begin
	    if fixStackTop < fixStackSize then
		begin
		    fixStackTop := fixStackTop + 1;
		    fixLabelNumber := fixLabelNumber + 1;
		    { Save the label used for the forward branch }
		    fixStack[fixStackTop] := fixLabelNumber;
		end
	    else
		Error (eFixStackOvfl)
	end;


    procedure FixForwardBranch (fromLabel: integer);	
	{ Emit the target label of a previously emitted forward branch }
	begin
	    EmitSunLabel ('f', fromLabel);
	end { FixForwardBranch };

    procedure FixAndFreeShuntList;
	{ All the elements in the top operand's shunt list (unresolved
	  forward branches) are fixed to have the address of the next
	  instruction to be emitted as their target.  The fixed shunt list
	  elements are returned to the shunt free list.			  }
	var
	    current:		ShuntRef;
	begin
	    current := operandStkValue[operandStkTop];
	    { Shunts must be processed in LIFO order. }
	    while current <> undefined do
		begin
		    FixForwardBranch (shuntAddress[current]);
		    current := shuntLink[current]
		end;
	    FreeShuntList (operandStkValue[operandStkTop]);
	end { FixAndFreeShuntList };

    procedure FixAndFreeFalseBranches;
	{ This performs the same function as FixAndFreeShuntList on the
	  top operand's false branch list.  It also clears the top operand's
	  jump condition and false branch fields.			   }
	var
	    current:		ShuntRef;
	begin
	    current := operandStkLength[operandStkTop];
	    { Addressess must be processed in LIFO order. }
	    while current <> undefined do
		begin
		    FixForwardBranch (shuntAddress[current]);
		    current := shuntLink[current]
		end;
	    FreeShuntList (operandStkLength[operandStkTop]);
	    operandStkKind[operandStkTop] := undefined;
	    operandStkLength[operandStkTop] := undefined
	end { FixAndFreeFalseBranches };



{  Temporary Register Mechanism procedures }

    procedure TempAllocate;
	var i: integer;
	begin
	    tempregnum := undefined;
	    i := firstTempReg;
	    while ((i <= lastTempReg) and (tempregnum = undefined)) do
		begin
		    if tempregfree [i] then 
			tempregnum := i;
		    i := i + 1
		end;
	    Assert (tempregnum <> undefined, assert52);
	    tempregfree[tempregnum] := false;
	end;
	
    procedure TempFree;
	begin
	    Assert (tempregnum <> undefined, assert53);
	    tempregfree[tempregnum] := true;
	end;

    procedure AssertTempsAreAllFree;
	var i: integer;
	begin
	    i := firstTempReg;
	    while (i <= lastTempReg) do
		begin
		    Assert (tempregfree [i], assert54);
		    i := i + 1
		end;
	end;



{  Operand Stack Mechanism procedures }

    procedure OperandPush (kind: integer;
			  value: integer;
			  regnum: integer;
			  length: integer);
	{ Push an operand stack entry with the parameter attributes }
	begin
	    if operandStkTop < operandStkSize then
		begin
		    operandStkTop := operandStkTop + 1;
		    operandStkKind[operandStkTop] := kind;
		    operandStkValue[operandStkTop] := value; 
		    operandStkRegnum[operandStkTop] := regnum; 
		    operandStkLength[operandStkTop] := length
		end
	    else
		Error (eOperandStkOvfl);
	end { OperandPush };


    procedure OperandPushProcedure;
	{ Push an operand stack entry for the procedure referenced
	  in the tCallEnd tcode just accepted.  }
	begin
	    Assert (compoundToken = tCallEnd, assert27);
	    OperandPush (mProc, compoundTokenValue, undefined, word);
	end { OperandPushProcedure };


    procedure OperandPushStringDescriptor;
	{ Push an operand stack entry for the string descriptor }
	begin
	    Assert ( (compoundToken = tStringDescriptor), assert28);
	    OperandPush (mString, compoundTokenValue, undefined, word);
	end { OperandPushStringDescriptor };


    procedure OperandPushArrayLowerBound;
	{ Push and operand stack entry which is the manifest value of
	  the lower bound of the array which is the current top operand. }
	var
	    descriptorAddress: integer;
	    lowerBound: integer;
	    i: integer;
	begin
	    Assert ( (operandStkTop >= 1), assert49);
	    Assert ( (operandStkKind[operandStkTop] = mStatic), assert50);
	    descriptorAddress := operandStkValue[operandStkTop];
	    i := 0;
	    { Locate the array's array table entry and copy its
	      lower bound field. }
	    while i < arrayBoundsTop do
		begin
		    i := i + 1;
		    if descriptorAddress = arrayDscrAddr[i] then
			begin
			    lowerBound := arrayLowers[i];
			    i := arrayBoundsTop + 1;
			end
		end;
	    { The array must be found in the array table }
	    Assert ( (i = arrayBoundsTop+1), assert51);

	    { Push the lower bound }
	    OperandPush (mManifest, lowerBound, undefined, word);
        end { OperandPushArrayLowerBound };


    procedure OperandComplementJumpCondition;
	{ Complement the top operand's jump condition and exchange its
	  shunt (true branch) list and false branch list fields,
	  since true branches become false branches (and vice versa)
	  when the condition field is inverted.			   }
	var
	    temp: integer;
	begin
	    ReverseSense (operandStkKind[operandStkTop]);
	    temp := operandStkValue[operandStkTop];
	    operandStkValue[operandStkTop] := operandStkLength[operandStkTop];
	    operandStkLength[operandStkTop] := temp
	end { OperandComplementJumpCondition };

    procedure OperandMergeShuntsWithAddress;
	{ The top fix stack address, which is the address of an unresolved
	  forward branch instruction, is added to the top operand's shunt list. }
	var
	    newShunt:	ShuntRef;
	begin
	    AllocateShunt (newShunt);
	    shuntAddress[newShunt] := fixStack[fixStackTop];
	    shuntLink[newShunt] := operandStkValue[operandStkTop];
	    operandStkValue[operandStkTop] := newShunt
	end { OperandMergeShuntsWithAddress };

    procedure OperandMergeShunts;
	{ Merge the shunt lists of the top 2 operands.  The lists are merged
	  in LIFO order (i.e. the first shunt of the second operand is 
	  linked to the last shunt of the top operand).			   }
	var
	    current:	ShuntRef;
	    previous:	ShuntRef;
	begin
	    current := operandStkValue[operandStkTop];
	    previous := undefined;
	    { Locate the end of the top operand's shunt list. }
	    while current <> undefined do
		begin
		    previous := current;
		    current := shuntLink[current]
		end;
	    if previous = undefined then
		{ The top operand has no shunt list. }
		operandStkValue[operandStkTop] := operandStkValue[operandStkTop - 1]
	      else
		{ Concatenate lists in LIFO order. }
		shuntLink[previous] := operandStkValue[operandStkTop-1]
	end { OperandMergeShunts };

    procedure OperandCompare (first: OperandStkRef; second: OperandStkRef);
	{ Set the S/SL result value to yes if the top 2 operands
	  are identical, otherwise set it to no.		}
	begin
	    if (operandStkKind[first] =
		operandStkKind[second]) and
	       (operandStkKind[first] <> mTemp) and
	       (operandStkKind[first] <> mAddressTempIndirect) and
	       (operandStkValue[first] =
		operandStkValue[second]) and
	       (operandStkRegnum[first] =
		operandStkRegnum[second]) and
	       (operandStkLength[first] =
		operandStkLength[second]) then
		resultValue := yes
	    else
		resultValue := no;
	end { OperandCompare };

    procedure OperandCopy (src: OperandStkRef; dst: OperandStkRef);
	{ Copy the source operand to the destination operand. }
	begin
	    operandStkKind[dst] := operandStkKind[src];
	    operandStkValue[dst] := operandStkValue[src];
	    operandStkRegnum[dst] := operandStkRegnum[src];
	    operandStkLength[dst] := operandStkLength[src];
	end { OperandCopy };

    procedure OperandSwap;
	{ Reverse the positions of the top 2 operand stack entries. }
	begin
	    if operandStkTop < operandStkSize then
		begin
		    OperandCopy (operandStkTop, operandStkTop+1);
		    OperandCopy (operandStkTop-1, operandStkTop);
		    OperandCopy (operandStkTop+1, operandStkTop-1);
		end
	    else
		Error (eOperandStkOvfl);
	end { OperandSwap };

    procedure OperandSwapRightAndDestination;
	{ Reverse the positions of the top and third operand stack entries. }
	begin
	    if operandStkTop < operandStkSize then
		begin
		    OperandCopy (operandStkTop, operandStkTop+1);
		    OperandCopy (operandStkTop-2, operandStkTop);
		    OperandCopy (operandStkTop+1, operandStkTop-2);
		end
	    else
		Error (eOperandStkOvfl);
	end { OperandSwapRightAndDestination };

    procedure OperandPop;
	begin
	    Assert ( (operandStkTop >= 1), assert13);
	    operandStkTop := operandStkTop - 1
	end { OperandPop };


    procedure OperandFoldManifestSubscript;
	{ Fold a manifest subscripting operation, replacing the array
	  operand with a simple variable operand.  Check that the
	  subscript is within the array bounds.  The top operand is the
	  manifest subscript,  the second operand is the array variable
	  The array's bounds are retrieved from the array table for
	  the subscript range check and calculation of the subscripted
	  variable's address.						}
	var
	    descriptorAddress: integer;
	    subscript: integer;
	    upperBound: integer;
	    lowerBound: integer;

	begin
	    Assert ( (operandStkTop >= 2), assert29);
	    Assert ( (operandStkKind[operandStkTop] = mManifest) and
		   (operandStkKind[operandStkTop-1] = mStatic), assert30);
	    subscript := operandStkValue[operandStkTop];
	    descriptorAddress := operandStkValue[operandStkTop-1];
	    i := 0;
	    { Locate the array's array table entry and copy its
	      lower and upper bound fields.			}
	    while i < arrayBoundsTop do
		begin
		    i := i + 1;
		    if descriptorAddress = arrayDscrAddr[i] then
			begin
			    lowerBound := arrayLowers[i];
			    upperBound := arrayUppers[i];
			    i := arrayBoundsTop + 1;
			end
		end;
	    { The array must be found in the array table }
	    Assert ( (i = arrayBoundsTop+1), assert31);
	    if (subscript  < lowerBound) or
	       (subscript  > upperBound) then
		SubscriptError (subscript, lowerBound, upperBound)
	      else
		begin
		    subscript := subscript - lowerBound;
		    if operandStkLength[operandStkTop-1] = word then
			{ Convert a byte offset to a word offset }
			subscript := subscript * wordSize;
		    { Set the subscripted varable's address.  Note that
		      the array variable's address points to the base of
		      a 2 word descriptor (lower, upper bounds).	}
		    operandStkValue[operandStkTop-1] := 
			operandStkValue[operandStkTop-1] +
			subscript + 2 * wordSize;  { size of 2 word descriptor }
		end;
	end { OperandFoldManifestSubscript };



    procedure OptionallyEmitSourceCoordinate;
	{ If the source coordinate has changed since the last source
	  coordinate update instruction was emitted and line 
	  numbering is turned on, emit another update instruction.
	  Use an increment (1 word) instruction where possible,
	  otherwise use a move (2 word) instruction.		    }
	begin
	    if lineNumbering and (lineNumber <> lastEmittedLineNumber) then
		begin
		    OperandPush (mLineReg, undefined, undefined, word);
		    if lineNumber = lastEmittedLineNumber + 1 then
			begin
			    EmitSingle (iInc);
			end
		      else
			begin
			    OperandPush (mManifest, lineNumber, undefined, word);
			    EmitDouble (iMov);
			    OperandPop
			end;
		    OperandPop;
		    lastEmittedLineNumber := lineNumber;
		end
	end { OptionallyEmitSourceCoordinate };













    procedure AcceptInputToken;
	{ This procedure provides the interface to the
	  previous pass;  it is reponsible for handling
	  all input including line number indicators and
	  the values and text associated with input tokens.  }
	var
	    acceptedToken: InputTokens;
	begin
	    Assert (nextInputToken <> tEndOfFile, assert4);

	    { Accept Token }
	    acceptedToken := nextInputToken;
	    tCodeAddress := nextTCodeAddress;

	    { If the token is a compound token,
	      read its associated value	    	}
	    if (acceptedToken >= firstCompoundToken) and 
	       (acceptedToken <= lastCompoundToken) then
		begin
		    compoundToken := acceptedToken;
		    read (tCode, compoundTokenValue);
		    nextTCodeAddress := nextTCodeAddress + 1;

		    case compoundToken of
			tLiteralAddress, tLiteralInteger, tLiteralChar,
			tLiteralBoolean, tStringDescriptor, tSkipString,
			tWhileTest, tWhileEnd, tRepeatTest, tCallEnd,
			tLineNumber, tTrap, tIfThen, tIfMerge, tSkipProc,
			tCaseSelect, tCaseMerge:
			    ;	{ Do nothing }
			tCaseEnd:
			    { Read the lowest and highest label values
			      followed by the case branch table.	}
			    begin
				caseLow := compoundTokenValue;
				read (tCode, caseHigh);
				i := 1;
				repeat
				    read (tCode, tCodeCaseTable[i]);
				    i := i + 1;
				until i > caseHigh - caseLow + 1;
				nextTCodeAddress := nextTCodeAddress +
					 (caseHigh - caseLow) + 2
			    end;
			tLiteralString:
			    begin
				compoundTokenLength := compoundTokenValue;
				Assert ( (compoundTokenLength >= 1), assert5);
				compoundTokenValue := nextTCodeAddress;
				i := 1;
				repeat
				    read (tCode, compoundTokenText[i]);
				    i := i + 1;
				until i > compoundTokenLength;
				nextTCodeAddress := nextTCodeAddress +
					compoundTokenLength;
				if compoundTokenLength mod 2 <> 0 then
				    compoundTokenText[compoundTokenLength+1] := null
			    end;
		    end		{ case compoundToken }
		end;

	    { Update Line Number }
	    lineNumber := nextLineNumber;

	    { Read Next Input Token }
	    repeat
		if eof (tCode) then
		    nextInputToken := tEndOfFile
		else
		    begin
			read (tCode, nextInputToken);
			nextTCodeAddress := nextTCodeAddress + 1;
		    end;

		if nextInputToken = tLineNumber then
		    begin
			{ Read the line number value }
			read (tCode, nextLineNumber);
			nextTCodeAddress := nextTCodeAddress + 1;
		    end;
	    until nextInputToken <> tLineNumber;

	    { Trace Input }
	    if tracing then
		begin
		    write ('Input token accepted ', acceptedToken: 1,
			';  Line ', lineNumber: 1, ';  Next input token ',
			nextInputToken: 1);
		    writeln;
		end;
	end { AcceptInputToken };

    procedure SslSyntaxError;
	{ Assert false since a syntax error can only be
	  the result of an error in the previous pass. }
	begin
	    Assert (false, assert7);
	end { SslSyntaxError };

    procedure SslTrace;
	begin
	    write ('Table index ', sslPointer-1: 1, ';  Operation ', 
		operation: 1, ';  Argument ', sslTable[sslPointer]: 1);
	    writeln;
	end { SslTrace };

    procedure SslFailure (failCode: FailureCodes);
	begin
	    write ('### S/SL program failure: ');

	    case failCode of
		fSemanticChoiceFailed:
		    write ('Semantic choice failed');
		fChoiceRuleFailed:
		    write ('Choice rule returned without a value');
	    end;

	    writeln;
	    write ('while processing line ', lineNumber);
	    writeln;
	    SslTrace;
	    Assert (false, assert8);
	end { SslFailure };

    procedure SslChoice (choiceTag: integer);

    { This procedure performs both input and semantic
     choices.  It sequentially tests each alternative
     value against the tag value, and when a match is
     found, performs a branch to the corresponding
     alternative path.  If none of the alternative
     values matches the tag value, sslTable interpretation
     proceeds to the operation immediately following
     the list of alternatives (normally the otherwise
     path).  The flag choiceTagMatched is set to true
     if a match is found and false otherwise.		}

	var
	    numberOfChoices:	integer;

	begin
	    sslPointer := sslPointer + sslTable[sslPointer];
	    numberOfChoices := sslTable[sslPointer];
	    sslPointer := sslPointer + 1;
	    choiceTagMatched := false;

	    repeat
		if sslTable[sslPointer] = choiceTag then
		    begin
			sslPointer := sslPointer + 1;
			sslPointer := sslPointer - sslTable[sslPointer];
			choiceTagMatched := true;
			numberOfChoices := 0;
		    end
		  else
		    begin
			sslPointer := sslPointer + 2;
			numberOfChoices := numberOfChoices - 1;
		    end;

	    until numberOfChoices = 0;

	    if tracing then
		begin
		    write ('Choice tag ', choiceTag : 1);
		    if choiceTagMatched then
			write (' (matched)')
		    else
			write (' (not matched)');
		    writeln
		end

	end { SslChoice };

    procedure GenerateCode;
    { Walk the ssl code generator table. }

	begin
	    { Initialize Table Walker State }
	    processing := true;
	    sslPointer := 0;
	    sslStackTop := 0;
	    noErrors := 0;
	    abort := false;
	    AcceptInputToken;

	    repeat { until processing = false }

		operation := sslTable[sslPointer];
		sslPointer := sslPointer + 1;

		if tracing then
		    SslTrace;

		case operation of

		    oCall:
			if sslStackTop < sslStackSize then
			    { no allowance for long calls }
			    begin
				sslStackTop := sslStackTop + 1;
				sslStack[sslStackTop] := sslPointer + 1;
				sslPointer := sslTable[sslPointer]
			    end
			  else
			    begin
				Error (eSslStackOvfl);
				processing := false
			    end;

		    oReturn:
			if sslStackTop > 0 then
			    begin
				sslPointer := sslStack[sslStackTop];
				sslStackTop := sslStackTop - 1
			    end
			  else
			    processing := false;	{ normal return }

		    oRuleEnd:
			SslFailure (fChoiceRuleFailed);

		    oJumpForward:
			sslPointer := sslPointer + sslTable[sslPointer];

		    oJumpBack:
			sslPointer := sslPointer - sslTable[sslPointer];

		    oInput:
			begin
			    if nextInputToken = sslTable[sslPointer] then
				AcceptInputToken
			      else
				SslSyntaxError;
			    sslPointer := sslPointer + 1
			end;

		    oInputAny:
			if nextInputToken <> tEndOfFile then
			    AcceptInputToken
			else
			    { Premature end of file }
			    SslSyntaxError;

		    oInputChoice:
			begin
			    SslChoice (nextInputToken);
			    if choiceTagMatched then
				AcceptInputToken
			end;

		    oEmit:
			{ No emitting operations }
			Assert (false, assert9);

		    oError:
			begin
			    Error (sslTable[sslPointer]);
			    sslPointer := sslPointer + 1
			end;

		    oChoice:
			SslChoice (resultValue);

		    oChoiceEnd:
			SslFailure (fSemanticChoiceFailed);

		    oSetParameter:
			begin
			    parameterValue := sslTable[sslPointer];
			    sslPointer := sslPointer + 1
			end;

		    oSetResult:
			begin
			    resultValue := sslTable[sslPointer];
			    sslPointer := sslPointer + 1
			end;



		    { ****
		      *  *  Fix Address Mechanism Operations
		      **** }

		    oFixPushLastAddress:
			FixPushLastAddress;

		    oFixPushAddress:
			FixPushAddress;

		    oFixPopAddress:
			begin
			    Assert ( (fixStackTop >= 1), assert10);
			    fixStackTop := fixStackTop - 1
			end;

		    oFixSwapAddresses:
			if fixStackTop < fixStackSize then
			    begin
				fixStack[fixStackTop+1] :=
					fixStack[fixStackTop];
				fixStack[fixStackTop] :=
					fixStack[fixStackTop-1];
				fixStack[fixStackTop-1] :=
					fixStack[fixStackTop+1];
			    end
			else
			    Error (eFixStackOvfl);

		    oFixAndFreeShuntList:
			FixAndFreeShuntList;

		    oFixAndFreeFalseBranches:
			FixAndFreeFalseBranches;

		    oFixForwardBranch:
			FixForwardBranch (fixStack[fixStackTop]);



		    { ****
		      *  *  Emit Mechanism Operations
		      **** }

		    oEmitProcLabel:
			EmitProcLabel (parameterValue);

		    oEmitNone:
			EmitNone (parameterValue);

		    oEmitSingle:
			EmitSingle (parameterValue);

		    oEmitDouble:
			EmitDouble (parameterValue);

		    oEmitString:
			EmitString;

		    oEmitStringLength:
			begin
			    Assert ( (compoundToken = tLiteralString), assert24);
			    EmitSunCode (iWord, false);
			    EmitSunDstMode (mWord, compoundTokenLength,
			    	undefined, undefined);
			end;

		    oEmitConditionalForwardBranch:
			EmitConditionalForwardBranch;

		    oEmitUnconditionalForwardBranch:
			EmitUnconditionalForwardBranch;

		    oEmitConditionalBackwardBranch:
			EmitConditionalBackwardBranch;

		    oEmitUnconditionalBackwardBranch:
			EmitUnconditionalBackwardBranch;

		    oEmitSourceCoordinate:
			begin
			    OptionallyEmitSourceCoordinate;
			    AssertTempsAreAllFree
			end;

		    oEmitMergeSourceCoordinate:
			{ The line number value must be explicitly set
			  not changed from the old value (e.g. inc  oldNum) }
			begin
			    lastEmittedLineNumber := undefined;
			    OptionallyEmitSourceCoordinate;
			    AssertTempsAreAllFree
			end;

		    oEmitCaseMergeBranch:
			begin
			    EmitSunCode (iJalways, false);
			    EmitSunDstLabel ('m', caseTCodeAddr[caseStackTop]);
			end;

		    oEmitCaseBranchTable:
			EmitCaseBranchTable;



		    { ****
		      *  *  Temporary Mechanism Operations
		      **** }

		    oTempAllocate:
			TempAllocate;

		    oTempFree:
			begin
			    tempregnum := operandStkRegnum[operandStkTop];
			    TempFree;
			end;



		    { ****
		      *  *  Operand Stack Mechanism Operations
		      **** }

		    oOperandPushVariable:
			{ Called after the acceptance of ANY variable token,
			  whether it be of a simple variable or an array.    }
			begin
			    Assert ( (compoundToken = tLiteralAddress), assert17);
			    OperandPush (mStatic, compoundTokenValue,
			        undefined, word);
			end;

		    oOperandPushInteger:
			begin
			    Assert ( (compoundToken = tLiteralInteger), assert18);
			    OperandPush (mManifest, compoundTokenValue,
				undefined, word)
			end;

		    oOperandPushChar:
			begin
			    Assert ( (compoundToken = tLiteralChar), assert19);
			    OperandPush (mManifest, compoundTokenValue,
				undefined, byte)
			end;

		    oOperandPushBoolean:
			begin
			    Assert ( (compoundToken = tLiteralBoolean), assert20);
			    OperandPush (mManifest, compoundTokenValue,
				undefined, byte)
			end;

		    oOperandPushMode, oOperandPushJumpCondition:
			OperandPush (parameterValue, undefined, undefined,
			    undefined);

		    oOperandPushTemp:
			OperandPush (mTemp, undefined, tempregnum, word);

		    oOperandChooseMode, oOperandChooseJumpCondition:
			resultValue := operandStkKind[operandStkTop];

		    oOperandSetMode:
			operandStkKind[operandStkTop] := parameterValue;

		    oOperandSetValue:
			operandStkValue[operandStkTop] := parameterValue;

		    oOperandChooseValue:
			resultValue := operandStkValue[operandStkTop];

		    oOperandIsValueNegative:
			if operandStkValue[operandStkTop] < 0 then
			    resultValue := yes
			else
			    resultValue := no;

		    oOperandSetLength:
			operandStkLength[operandStkTop] := parameterValue;

		    oOperandChooseLength:
			resultValue := operandStkLength[operandStkTop];

		    oOperandPushCaseLow:
			OperandPush (mManifest, caseLow, undefined, word);

		    oOperandPushCaseHigh:
			OperandPush (mManifest, caseHigh, undefined, word);

		    oOperandPushProcedure:
			OperandPushProcedure;

		    oOperandPushStringDescriptor:
			OperandPushStringDescriptor;

		    oOperandPushTrap:
			begin
			    Assert ( (compoundToken = tTrap), assert22);
			    OperandPush (mTrap, compoundTokenValue,
				undefined, word);
			end;

		    oOperandPushArrayLowerBound:
			OperandPushArrayLowerBound;

		    oOperandPushCopy:
			OperandPush (operandStkKind[operandStkTop],
			    operandStkValue[operandStkTop],
			    operandStkRegnum[operandStkTop],
			    operandStkLength[operandStkTop]);

		    oOperandEnterValueFromCaseTableAddress:
			 operandStkValue[operandStkTop] := 
			     caseTCodeAddr[caseStackTop];

		    oOperandEnterValueFromCodeAddress:
			 operandStkValue[operandStkTop] := 0; {[ nextLoc; ]}

		    oOperandEnterValueFromDataAreaSize:
			operandStkValue[operandStkTop] := dataAreaSize;

		    oOperandEnterValueFromStringLength:
			begin
			    Assert ( (compoundToken = tLiteralString), assert32);
			    operandStkValue[operandStkTop] :=
				compoundTokenLength;
			end;

		    oOperandCompareLeftAndRight:
			begin
			    Assert ( (operandStkTop >= 2), assert15);
			    OperandCompare (operandStkTop, operandStkTop-1)
			end;

		    oOperandCompareRightAndDestination:
			begin
			    Assert ( (operandStkTop >= 3), assert16);
			    OperandCompare (operandStkTop, operandStkTop-2)
			end;

		    oOperandIsJumpCondition:
			if operandStkKind[operandStkTop] <= lastJumpCode then
			    resultValue := yes
			else
			    resultValue := no;

		    oOperandComplementJumpCondition:
			OperandComplementJumpCondition;

		    oOperandAddManifestValues:
			begin
			    Assert ( (operandStkTop >= 2), assert11);
			    operandStkValue[operandStkTop-1] :=
				operandStkValue[operandStkTop-1] +
				operandStkValue[operandStkTop];
			end;

		    oOperandSubtractManifestValues:
			begin
			    Assert ( (operandStkTop >= 2), assert12);
			    operandStkValue[operandStkTop-1] :=
				operandStkValue[operandStkTop-1] -
				operandStkValue[operandStkTop];
			end;

		    oOperandNegateManifestValue:
			operandStkValue[operandStkTop] :=
				-operandStkValue[operandStkTop];

		    oOperandChooseManifestValue:
			if operandStkKind[operandStkTop] = mManifest then
			    resultValue := operandStkValue[operandStkTop]
			else
			    resultValue := undefined;

		    oOperandCompareManifestValues:
			if operandStkValue[operandStkTop] =
				operandStkValue[operandStkTop-1] then
			    resultValue := yes
			else
			    resultValue := no;

		    oOperandFoldManifestSubscript:
			OperandFoldManifestSubscript;

		    oOperandMergeShuntsWithAddress:
			OperandMergeShuntsWithAddress;

		    oOperandMergeShunts:
			OperandMergeShunts;

		    oOperandSwap:
			OperandSwap;

		    oOperandSwapRightAndDestination:
			OperandSwapRightAndDestination;

		    oOperandPop:
			OperandPop;




		    { ****
		      *  *  Array Table Mechanism Operations
		      **** }

		    oArrayEnterLowerBound:
			if arrayBoundsTop < maxArrayBounds then
			    begin
				arrayBoundsTop := arrayBoundsTop + 1;
				{ Descriptor address is the address of
				  the lower bound.		      }
				arrayDscrAddr[arrayBoundsTop] :=
					operandStkValue[operandStkTop-1];
				arrayLowers[arrayBoundsTop] :=
					operandStkValue[operandStkTop];
			    end
			else
			    Error (eArrayBoundsOvfl);

		    oArrayEnterUpperBound:
			arrayUppers[arrayBoundsTop] :=
				operandStkValue[operandStkTop];



		    { ****
		      *  *  Case Mechanism Operations
		      **** }

		    oCasePush:
			if caseStackTop < caseStackSize then
			    caseStackTop := caseStackTop + 1
			else
			    Error (eCaseStackOvfl);

		    oCasePop:
			begin
			    Assert ( (caseStackTop >= 1), assert36);
			    caseStackTop := caseStackTop - 1;
			end;

		    oCaseEnterTCodeAddress:
			caseTCodeAddr[caseStackTop] := tCodeAddress;

		    oCaseEnterVariantAddress:
			EmitSunLabel ('v', tCodeAddress);

		    oCaseEnterMergeAddress:
			EmitSunLabel ('m', caseTCodeAddr[caseStackTop]);

		    oCaseEnterAbortAddress:
			EmitSunLabel ('a', caseTCodeAddr[caseStackTop]);


		    { Option Mechanism Operations }

		    oOptionTestChecking:
			if checking then
			    resultValue := yes
			else
			    resultValue := no;

		end { case operation };

	    until not processing;

	    if not abort then
		Assert (eof (tCode), assert25);

	end;    { GenerateCode }


    procedure Finalize;
	begin
	    { If the table walker terminated normally check that the state
	      of the semantic mechanisms is legal.			 }
	    if not abort then
		{ If everything happened legitimately, the temporaries
		  should all be free and the mechanism stacks should 
		  all be empty.		   				}
		begin
		    AssertTempsAreAllFree;
		    Assert (operandStkTop = 0, assert45);
		    Assert (fixStackTop = 0, assert46);
		    Assert (caseStackTop = 0, assert47);
		end;

	end { Finalize };

    begin
	{ N.B. We assume here that the invoker of the coder (e.g. the
	  ptc command) has insured that the token stream emitted by
	  the semantic pass is valid (i.e. no semantic errors detected) .
	  If the stream is illegal the first word will be a positive
	  integer value.						}

	Initialize;
	GenerateCode;
	Finalize;
    end.
