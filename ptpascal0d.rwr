ptpascal0d {
  Program [_program ID FormalParameters _semicolon Block _dot] =
    ‛\n(define («ID» «FormalParameters») «Block»)’

  FormalParameters_empty [_lp _rp] = ‛’
  FormalParameters_nonempty [_lp p ps* _rp] = ‛«p» «ps»’
  
  FormalParameter_var [_var ID] = ‛«ID»’
  FormalParameter_id [ID] = ‛«ID»’
    
  CommaFormalID [_comma FormalID] = ‛«FormalID»’
  FormalID [ID] = ‛«ID»’

  Block [ConstantDefinitions] = ‛«ConstantDefinitions»’

  ConstantDefinitions_consts [_const def] = ‛«def»’
  ConstantDefinitions_noconsts [typedef] = ‛«typedef»’
  TypeDefinitions_types [_type TypeDefinition] = ‛«TypeDefinition»’
  TypeDefinitions_notypes [VariableDefinitions] = ‛«VariableDefinitions»’
  VariableDeclarations_variables [_var VariableDeclaration] = ‛«VariableDeclaration»’
  VariableDeclarations_novariables [ProcedureDefinitions] = ‛«ProcedureDefinitions»’

    ConstantDefinition_consts [ID _eq ConstantValue _semicolon ConstantDefinition] = ‛\n(let ((«ID» «ConstantValue»)) «ConstantDefinition»)’
    ConstantDefinition_noconsts [TypeDefinitions] = ‛«TypeDefinitions»’
    TypeDefinition_types [ID _eq TypeBody _semicolon TypeDefinition] = ‛\n⟪+ name=«ID» kind=type def=«TypeBody»⟫«TypeDefinition»’
    TypeDefinition_notypes [VariableDeclarations] = ‛«VariableDeclarations»’
    VariableDeclaration_vars [ID _colon TypeBody _semicolon VariableDeclaration] = ‛\n(let ((ID ⟪name=«ID» kind=var type=«TypeBody»⟫ nil))«VariableDeclaration»)’
    VariableDeclaration_novars [ProcedureDefinitions] = ‛«ProcedureDefinitions»’
    ProcedureDefinitions_proc [_procedure ID ProcedureHeading Block _semicolon ProcedureDefinitions] =‛\n(let ((«ID» (lambda («ProcedureHeading»)«Block»)))«ProcedureDefinitions»)’
    ProcedureDefinitions_noproc [BeginStatement] =‛«BeginStatement»’

    ConstantValue [v] = ‛«v»’ 

    TypeBody_packedarray [_packed _array _lb SimpleType _rb _of SimpleType] = ‛⟪+ kind=type def=packedArray («SimpleType»)⟫’
    TypeBody_array [_array _lb SimpleType _rb _of SimpleType] = ‛⟪+ kind=type def=array («SimpleType»)⟫’
    TypeBody_file [_file _of SimpleType] = ‛⟪+ kind=type def=file («SimpleType»)⟫’
    TypeBody_simple [SimpleType] = ‛⟪+ kind=type def=«SimpleType»⟫’

    SimpleType_idrange [ID _dotdot Integer] = ‛⟪+ kind=type def=idrange («ID» «Integer»)⟫’
    SimpleType_id [ID] = ‛⟪+ kind=type def=«ID»⟫’
    SimpleType_intrange [Integer1 _dotdot Integer2] = ‛⟪+ kind=type def=idrange («Integer1» «Integer2»)⟫’

   ProcedureHeading [FormalParameters _semicolon] = ‛«FormalParameters»’


     Continuation [_semicolon Statement] = ‛«Statement»’
     
     BeginStatement [_begin Statement _end cont?] = ‛\n(progn«Statement»)«cont»’

     Statement [s] =‛«s»’

     IfStatement [_if Expression _then Statement ElseStatement? cont?] = ‛\n(if «Expression»«Statement»«ElseStatement»)«cont»’
     ElseStatement [_else Statement] = ‛«Statement»’

     WhileStatement [_while Expression _do Statement cont?] = ‛(while «Expression»«Statement»)«cont»’
     CaseStatement [_case Expression _of CaseAlternative+ _end cont?] ‛«_.pushNewSymbol()»’ = ‛(let ((«_.symbol()» «Expression»))«CaseAlternative»)«_.popSymbol()»«cont»’
     RepeatStatement [_repeat Statement _until Expression cont?] = ‛\n(repeat«Statement»\n«Expression»)«cont»’
     AssignmentStatement [Lval _assign Expression cont?] = ‛\n(let ((«Lval» «Expression»))«cont»)’
     CallStatement_withargs [ID _lb Arg MoreArgs* _rb cont?] = ‛\n(«ID» «Arg» «MoreArgs»)«cont»’
     CallStatement_noargs [ID  cont?] =  ‛\n(«ID»)«cont»’

     Arg [e] = ‛«e»’
     ArgWithFieldWidth [e fieldWidth] = ‛(field-width «fieldWidth» «e»)’
     ColonExpression [_colon Expression] = ‛«Expression»’
     CommaArg [_comma Arg] = ‛«Arg»’

       Lval_subscripted [ID _lb Expression _rb] = ‛(aref «ID» «Expresssion»)’
       Lval_plain [ID] = ‛«ID»’

	 
       CaseAlternative [Integer MoreIntegers? _colon Statement] = ‛\n((«Integer» «MoreIntegers»)«Statement»)’
       CommaInteger [_comma Integer CommaInteger?] = ‛«Integer» «CommaInteger»’

       Expression [bOR] = ‛«bOR»’
       BooleanOrExpression_or [e _or eor] = ‛(or «e» «eor»)’
       BooleanOrExpression_other [e] = ‛«e»’
       BooleanAndExpression_and [e _and eand] = ‛(and «e» «eand»)’
       BooleanAndExpression_other [e] = ‛«e»’

       BooleanExpression_eq [se _eq be] = ‛(= «se» «be»)’
       BooleanExpression_ne [se _ne be] = ‛(not (= «se» «be»))’
       BooleanExpression_lt [se _lt be] = ‛(< «se» «be»)’
       BooleanExpression_le [se _le be] = ‛(<= «se» «be»)’
       BooleanExpression_gt [se _gt be] = ‛(> «se» «be»)’
       BooleanExpression_ge [se _ge be] = ‛(>= «se» «be»)’
       BooleanExpression_other [se] = ‛«se»’

      SimpleExpression_minus [Term _minus SimpleExpression] = ‛(- «Term» «SimpleExpression»)’
      SimpleExpression_plus [Term _plus SimpleExpression] = ‛(+ «Term» «SimpleExpression»)’
      SimpleExpression_other [Term] = ‛«Term»’

      Term_mul [f1 _asterisk f2] = ‛(* «f1» «f2»)’
      Term_div [f1 _div f2] = ‛(div «f1» «f2»)’
      Term_mod [f1 _mod f2] = ‛(mod «f1» «f2»)’
      Term_other [f1] = ‛«f1»’

      Factor_parenthesized [_lb f _rb] = ‛«f»’
      Factor_not [_not f] = ‛(not «f»)’
      Factor_lit [Literal] = ‛«Literal»’
      Factor_int [Integer] = ‛«Integer»’
      Factor_negvar [_minus v] = ‛(- «v»)’ 
      Factor_var [_plus? v] = ‛«v»’ 

      Variable_subscript [Variable Subscript] = ‛(aref «Variable» «Subscript»)’
      Variable [ID] = ‛«ID»’

      Subscript [_lb e _rb] = ‛«e»’          
       
       Integer_neg [_minus unsignedInteger] = ‛(- «unsignedInteger»)’
       Integer_other [_plus? unsignedInteger] = ‛«unsignedInteger»’

          id [_lb s _rb] = ‛«s»’
          kw [s] = ‛«s»’
          ID [_lb idchar+ _rb] = ‛«idchar»’
          idchar [c] = ‛«c»’
          unsignedInteger [digits+] = ‛«digits»’
          Literal [_lq litchar* _rq] = ‛"«litchar»"’
          litchar [c] = ‛«c»’
}
